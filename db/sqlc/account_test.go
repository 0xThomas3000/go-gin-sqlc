package db

import (
	"context"
	"database/sql"
	"testing"
	"time"

	"github.com/0xThomas3000/go-gin-sqlc/v2/util"
	"github.com/stretchr/testify/require"
)

// Won't run as a Unit Test because it doesn't have the Test prefix. It should return the created Account record
// so that other unit tests can have enough data to perform their own operation.
func createRandomAccount(t *testing.T) Account {
	arg := CreateAccountParams{
		Owner:    util.RandomOwner(),
		Balance:  util.RandomMoney(),
		Currency: util.RandomCurrency(),
	}

	account, err := testQueries.CreateAccount(context.Background(), arg)
	require.NoError(t, err)      // Pass in the testing.T object, err returned by the CreateAccount()
	require.NotEmpty(t, account) // The returned account should not be an empty obj

	// Check if they're matched with input arguments.
	require.Equal(t, arg.Owner, account.Owner)
	require.Equal(t, arg.Balance, account.Balance)
	require.Equal(t, arg.Currency, account.Currency)

	require.NotZero(t, account.ID)        // Check account.ID is automatically generated by Postgres -> require it to be not Zero.
	require.NotZero(t, account.CreatedAt) // The 'created_at' column should be filled with the current timestamp

	return account
}

// Unit test for CreateAccount function
func TestCreateAccount(t *testing.T) {
	// The last thing you want: when a simple change in a test affects the result of some other ones
	// -> For this reason: each test should create its own account records.
	// To avoid code duplication: should write a seperate function to create a random account
	createRandomAccount(t)
}

func TestGetAccount(t *testing.T) {
	// To test all of other CRUD operations, need create an account first
	// Note that when writing unit tests, should make sure they're independents from each other
	// because it's hard to maintain if we have hundred of tests that depends on each other.
	account1 := createRandomAccount(t) // Save the created record to account1
	account2, err := testQueries.GetAccount(context.Background(), account1.ID)
	require.NoError(t, err)
	require.NotEmpty(t, account2)

	// Require all data fields of account2 should equal to those of account1
	require.Equal(t, account1.ID, account2.ID)
	require.Equal(t, account1.Owner, account2.Owner)
	require.Equal(t, account1.Balance, account2.Balance)
	require.Equal(t, account1.Currency, account2.Currency)
	// For the timestamp fields like 'created_at': we check 2 timestamps are different by at most some 'delta duration'
	// In this case: chose delta = 1 second
	require.WithinDuration(t, account1.CreatedAt, account2.CreatedAt, time.Second)
}

func TestUpdateAccount(t *testing.T) {
	account1 := createRandomAccount(t)

	arg := UpdateAccountParams{
		ID:      account1.ID,
		Balance: util.RandomMoney(),
	}

	account2, err := testQueries.UpdateAccount(context.Background(), arg) // Pass in 2 params with the update 'arg'
	require.NoError(t, err)                                               // then we require no errors to be returned
	require.NotEmpty(t, account2)                                         // the updated account2 object should not be empty

	// Compare each individual field of account2 to account1. Almost all of them should be the same except for the 'balance'
	require.Equal(t, account1.ID, account2.ID)
	require.Equal(t, account1.Owner, account2.Owner)
	require.Equal(t, arg.Balance, account2.Balance)
	require.Equal(t, account1.Currency, account2.Currency)
	require.WithinDuration(t, account1.CreatedAt, account2.CreatedAt, time.Second)
}

func TestDeleteAccount(t *testing.T) {
	account1 := createRandomAccount(t)
	err := testQueries.DeleteAccount(context.Background(), account1.ID)
	require.NoError(t, err)

	account2, err := testQueries.GetAccount(context.Background(), account1.ID) // Makesure that Account is really deleted
	require.Error(t, err)
	require.EqualError(t, err, sql.ErrNoRows.Error()) // To check that 'the error should be sql.ErrNoRows'
	require.Empty(t, account2)                        // Check that the 'account2' object should be empty
}

func TestListAccounts(t *testing.T) {
	for i := 0; i < 10; i++ {
		createRandomAccount(t) // Create several Accounts
	}

	arg := ListAccountsParams{ // Declare the list-accounts parameters
		Limit:  5, // Skip the first 5 records
		Offset: 5, // Return the next 5
	}

	// When we run the tests, there'll be at least 10 Accounts in the DB, so with these parameters,
	// we expect to get 5 records. -> call ListAccounts with the Background context and 'parameters' arg
	accounts, err := testQueries.ListAccounts(context.Background(), arg)
	require.NoError(t, err)
	require.Len(t, accounts, 5) // Require the length of the returned accounts slice to be 5

	for _, account := range accounts { // Iterate through the list of accounts
		require.NotEmpty(t, account) // Require each of them to be 'not empty'
	}
}
